Харківський університет радіоелектроніки
Факультет комп'ютерних наук
Кафедра програмної інженерії



ЗВІТ
до практичної роботи номер 1 з дисципліни
"Аналіз та рефакторинг коду"
на тему: "Правила оформлення програмного коду"



Виконала ст. гр ПЗПІ-22-4
Герасимова Владислава Андріївна

Перевірив
ст. викладач кафедри ПІ
Сокорчук Ігор Петрович



Харків 2024
МЕТА
	Ознайомитися з основними рекомендаціями щодо написання чистого, ефективного та підтримуваного коду для мови програмування C++, а також навчитися аналізувати та рефакторити код для покращення його якості.

ВСТУП
	С++ - це дуже потужна та широковживана мова програмування загального призначення. Те, як багато програмістів її використовують та те, як багато можливостей вона їм надає, призводить до того, що існування певних правил грамотного оформлення коду на ній є необхідним заради запобігання повному хаосу.
	Правила грамотного оформлення коду мають на меті зробити код більш читабельним, зрозумілим, зручним для подальшої підтримки та розвитку, та, в ідеалі, ефективним.
	Певні правила грамотного оформлення коду є достатньо універсальними між різними мовами програмування та в межах певних мов (наприклад правила SOLID та основні рекомендації по підвищенню ефективності та продуктивності коду). В той самий час, більш «декоративні» правила, пов’язані скоріш із зовнішнім виглядом коду, ніж із його роботою, часто формуються окремо під час початку роботи певної команди над новим проектом. Враховуючи це варто пам’ятати, що такого типу рекомендації, наведені нижче, є достатньо гнучкими і можуть бути відкоригованими, чи взагалі відкинутими, якщо вони є незручними чи недоцільними для певної конкретної команди.
	Також варто враховувати, що наведені нижче рекомендації – це далеко не всі рекомендації по грамотному написанню коду на мові С++. Для отримання більш повного списку рекомендується звернутися до [1].
 
РЕКОМЕНДАЦІЇ ДЛЯ НАПИСАННЯ КОДУ

Рекомендація: Використовуйте єдиний стиль іменування
Опис: Узгодженість у стилі іменування змінних і функцій підвищує читабельність коду, роблячи його зрозумілішим для інших розробників. Це допомагає уникати плутанини та помилок, що можуть виникати через неправильне використання або повторне використання імен.
Приклад:
// поганий приклад
int my_map1;
int MyMap2;
int MYMAP3;

// гарний приклад
int my_map_1;
int my_map_2;
int my_map_3;

Рекомендація: Використовуйте великий регістр (ALL_CAPS) для імен макросів та уникайте використання ALL_CAPS для інших змінних
Опис: Макроси функціонують відмінно від звичайних змінних, і тому повинні бути чітко відокремлені від них. Використання великого регістру дозволяє легко помітити макроси, зменшуючи ризик випадкових підмін.
Приклад:
// поганий приклад
#define forever for (;;) // можна переплутати зі змінною
int MYMAP3; // можна переплутати із макросом

// гарний приклад
#define FOREVER for(;;) // better
int my_map_3;

Рекомендація: Використовуйте зрозумілі назви та конструкції
Опис: Чіткі назви змінних та функцій полегшують розуміння коду іншими розробниками і знижують потребу в зайвих коментарях.
Приклад:
// поганий приклад
int f(int v1, int v2) {
    int v3 = v1 / v2;
    return v3;
}

// гарний приклад
int division(int divident, int divider) {
    int result = divident / divider;
    return result;
}

Рекомендація: Не використовуйте однакові імена змінних у вкладених областях видимості
Опис: Використання однакових імен у різних областях видимості може призвести до плутанини та проблем з підтримкою коду. Це ускладнює розуміння того, яка саме змінна використовується в певний момент.
Приклад:
// поганий приклад
int d = 0;
if (true) {
    d = 9;
}
else {
    int d = 7; // повторне використання імені
    //...
    d = 5;
}
std::cout << d;

// гарний приклад
int d = 0;
if (true) {
    d = 9;
}
else {
    int e = 7;
    //...
    d = 5;
}
std::cout << d;

Рекомендація: Уникайте кодування типів у назвах змінних або функцій, перевантажуйте функції зі схожею функціональністю
Опис: Назви повинні відображати функціональність, а не типи даних.
Приклад:
// поганий приклад
void print_int(int i) {
    std::cout << i << std::endl;
}

void print_string(std::string s) {
    std::cout << s << std::endl;
}

// гарний приклад
void print(int i) {
    std::cout << i << std::endl;
}

void print(std::string s) {
    std::cout << s << std::endl;
}

Рекомендація: Оголошуйте змінні лише тоді, коли вони необхідні
Опис: Оголошуйте змінні безпосередньо перед їх використанням і завжди ініціалізуйте їх значенням. Це дозволяє уникати помилок, пов'язаних з неініціалізованими змінними, та спрощує підтримку коду.
Приклад:
// поганий приклад
int i;
//...
i = 7;   // пізня ініціалізація
//...
std::cout << i;

// гарний приклад
int i = 7;   // ініціалізація відразу після об’явлення
std::cout << i;

Рекомендація: Зберігайте області видимості змінних якомога меншими
Опис: Це підвищує читабельність коду, мінімізує утримання ресурсів і запобігає випадковому використанню невідповідних значень змінних.
Приклад:
// поганий приклад
int i;
for (i = 0; i < 10; ++i) {
    //...
}
// i все ще доступна

// гарний приклад
for (int i = 0; i < 10; ++i) {
    // i локальна для циклу
}

Рекомендація: Не використовуйте одну змінну для різних цілей
Опис: Використання змінної для кількох різних цілей знижує читабельність і може призвести до помилок. Краще створити окремі змінні для кожної логічної мети.
Приклад:
// поганий приклад
int i;
for (i = 0; i < 20; ++i) {
    //...
}
for (i = 0; i < 200; ++i) {
    //...
}

// гарний приклад
for (int i = 0; i < 20; ++i) {
    //...
}
for (int j = 0; j < 200; ++j) {
    //...
}

Рекомендація: Організовуйте пов'язані дані у структури або класи
Опис: Згруповані дані, які логічно пов'язані між собою, повинні бути структуровані відповідним чином для полегшення розуміння та підтримки коду.
Приклад:
// поганий приклад
void badUngroupedData(int x1, int y1, int x2, int y2);

// гарний приклад
struct Point {
    int x;
    int y;
};

void goodGroupedData(Point from, Point to);

Рекомендація: Не визначайте клас або enum та не оголошуйте змінну його типу в одному виразі
Опис: Змішування визначення типу та визначення іншої сутності в одній декларації є заплутаним і непотрібним.
Приклад:
// поганий приклад
struct BadDeclaration {
    int x;
} bad_struct{ 2 };

// гарний приклад
struct GoodDeclaration {
    int x;
};
GoodDeclaration good_struct{ 2 };

Рекомендація: Уникайте тривіальних геттерів і сеттерів
Опис: Тривіальний геттер або сеттер не додає ніякої семантичної цінності; елемент даних з таким же успіхом може бути public.
Приклад:
// поганий приклад
class BadGetterSetter {
private:
    int x;
public:
    int getX() { return x; }
    void setX(int val) { x = val; }
};

// гарний приклад
class GoodClass {
public:
    int x;
};

Рекомендація: Визначайте оператори для імітації їх звичної та логічної поведінки
Опис: Оператори повинні наслідувати звичні правила їх використання для забезпечення інтуїтивності та зрозумілості коду.
Приклад:
// поганий приклад
class X {
public:
    int value;
    X operator+(const X& other) {
        return X{ value - other.value };
    }
};

// гарний приклад
class X {
public:
    int value;
    X operator+(const X& other) {
        return X{ value + other.value };  // Correct use of + operator
    }
};

Рекомендація: Надавайте перевагу enum над макросами
Опис: Макроси не підпорядковуються правилам області видимості та типів, що може спричиняти помилки. Enum краще підходить для таких випадків.
Приклад:
Example
// поганий приклад
#define RED 0
#define BLUE 1
int color = RED;  // Макрос замість enum

// гарний приклад
enum class Color { red, blue };
Color color = Color::red;
 
Рекомендація: Вказуйте значення enum лише за необхідності.
Опис: Мануальне вказування значень для enum часто є непотрібним та може призвести до помилок, викликаних неуважністю програмісту.
Приклад:
// поганий приклад
enum class BadColor { red = 1, blue = 2, green = 2 };

// гарний приклад
enum class Color { red, blue, green };
enum class Month { jan = 1, feb, mar, apr, may, jun,  jul, aug, sep, oct, nov, dec };

Рекомендація: Використовуйте switch замість if, коли є вибір між константами
Опис: Switch-оператори зазвичай є більш оптимізованими та зрозумілими, ніж ланцюжок if-else операторів.
Приклад:
// поганий приклад
void badIfElseSequence(int flag) {
    if (flag == 0) {
        //...
    }
    else if (flag == 1) {
        //...
    }
    else if (flag == 2) {
        //...
    }
    else {
        //...
    }
}

// гарний приклад
void goodSwitchUsage(int flag) {
    switch (flag) {
    case 0:
        //...
        break;
    case 1:
        //...
        break;
    case 2:
        //...
        break;
    default:
        //...
        break;
    }
}

Рекомендація: Надавайте перевагу range-for над for коли можливо, for над while коли існує очевидна змінна циклу, та while над for коли такої змінної немає (в інших випадках).
Опис: Це дозволяє знизити кількість потенціальних помилок, підвищити зрозумілість та ефективність коду, зменшити область видимості змінної циклу. 
Приклад:
// поганий приклад
void badForWhileUsage(std::vector<int> values) {
    for (int i = 0; i < values.size(); i++) {
        std::cout << values[i] << std::endl;
    }

    int j = 0;
    while (j < values.size()) {
        std::cout << values[j] << std::endl;
    }
}

// гарний приклад
void goodForUsage(std::vector<int> values) {
    for (auto v : values) {
        std::cout << v << std::endl;
    }
}

Рекомендація: Завжди додавайте break у не пусті case блоки в switch
Опис: Випадкове пропущення break може призвести до помилок і неочікуваної поведінки коду. Це також ускладнює підтримку.
Приклад:
// поганий приклад
void badSwitchFallthrough(int eventType) {
    switch (eventType) {
    case 1:
        std::cout << "Warning\n";
        // Bad: implicit fallthrough
    case 2:
        std::cout << "Error\n";
        break;
    }
}

// гарний приклад
void goodSwitch(int eventType) {
    switch (eventType) {
    case 1:
        std::cout << "Warning\n";
        break;
    case 2:
        std::cout << "Error\n";
        break;
    default:
        std::cout << "Unknown\n";
        break;
    }
}

Рекомендація: Використовуйте винятки лише для обробки помилок
Опис: Це робить код більш логічним та послідовним, відокремилюючи обробку помилок від «звичайного коду». Дозволяє позбутися помилок та неочікуваної роботи коду, пов’язаної з тим, що C++ код, як правило, оптимізується на основі припущення, що винятки трапляються рідко.
Приклад:
// поганий приклад
int badExceptionUsage(std::vector<int> values, int v) {
    try {
        for (int i = 0; i < values.size(); i++) {
            if (values[i] == v) {
                throw i;
            }
        }
    }
    catch (int i) {
        return i;
    }

    return  -1;
}

// гарний приклад
int goodNoExceptions(std::vector<int> values, int v) {
    for (int i = 0; i < values.size(); i++) {
        if (values[i] == v) {
            return i;
        }
    }

    return  -1;
}

Рекомендація: Використовуйте спеціально створені користувацькі типи для винятків (а не вбудовані типи).
Опис: Користувацькі винятки краще передають інформацію про помилки до обробника. У самому типі можна закодувати додаткову інформацію, яка буде корисною під час обробки відповідних помилок. Крім того, користувацькі типи менш схильні до конфліктів з іншими винятками.
Приклад: 
// поганий приклад
int badExceptionUsage(int a, int b) {
    if (b == 0) {
        throw "Division by zero";
    }
    return a / b;
}

// гарний приклад
class DivisionByZeroException : public std::runtime_error {
public:
    DivisionByZeroException()
        : std::runtime_error("Division by zero error") {}
};

int goodExceptionUsage(int a, int b) {
    if (b == 0) {
        throw DivisionByZeroException();
    }
    return a / b;
}
	
Рекомендація: Якщо є сумніви щодо пріоритету операторів, використовуйте дужки
Опис: Дужки допомагають уникнути помилок і роблять код більш зрозумілим, особливо у випадках складних операцій.
Приклад:
// поганий приклад
void badOperatorUsage(const unsigned int mask, unsigned int value) {
    if (value & mask == 1)  // виконується: value & (mask == 1), тобто маска спочатку порівнюється з 1
    {
        std::cout << "Mask matches the value" << std::endl;
    }
    else {
        std::cout << "No match" << std::endl;
    }
}

// гарний приклад
void goodOperatorUsage(const unsigned int mask, unsigned int value) {
    if ((value & mask) == 1) {
        std::cout << "Mask matches the value" << std::endl;
    }
    else {
        std::cout << "No match" << std::endl;
    }
}

Рекомендація: Не змішуйте знакові та беззнакові значення при обчисленнях
Опис: Більшість арифметичних дій вважається знаковими, тому саме знакові типи використовуються для арифметичних обчислень. Беззнакові типи підтримують маніпуляції з бітами без сюрпризів від знакових бітів, тому вини використовуються саме для маніпуляцій з бітами. Змішення знакових та беззнакових типів при обчисленнях може призвести до неочікуваних результатів.
Приклад:
// поганий приклад
int v1 = -10;
unsigned int v2 = 3;
std::cout << v1 - v2 << std::endl;
std::cout << v1 + v2 << std::endl;
std::cout << v1 * v2 << std::endl;

// гарний приклад
int v1 = -10;
int v2 = 3;
std::cout << v1 - v2 << std::endl;
std::cout << v1 + v2 << std::endl;
std::cout << v1 * v2 << std::endl;


Рекомендація: Економно використовуйте пробіли, але робіть порожні оператори видимими
Опис: Надлишок пробілів ускладнює сприйняття коду. При цьому порожні оператори повинні бути чітко помітними, щоб уникнути випадкових помилок.
Приклад:
// поганий приклад
void badSpaceUsage(int args [ ], int args_count) {
    for ( int i = 0; i < args_count; i ++ ) {

        std::cout << args [ i ] << std::endl;

    }


    for ( int i = 0; i < 100; i++ ); // легко не помітити
}

// гарний приклад
void goodSpaceUsage(int args[], int args_count) {
    for (int i = 0; i < args_count; i++) {
        std::cout << args[i] << std::endl;
    }

    for (int i = 0; i < 100; i++) {
        //nothing
    }
}

Рекомендація: Функція повинна виконувати одну логічну операцію
Опис: Функцію, яка виконує одну операцію, простіше зрозуміти, протестувати і використовувати повторно.
Приклад:
// поганий приклад
void readProcessAndPrint() {
    int a, b;
    std::cin >> a >> b;

    int sum = a + b;

    std::cout << "Sum: " << sum << std::endl;
}

// гарний приклад
int read(std::istream& is) {
    int x;
    is >> x;
    return x;
}

int process(int a, int b) {
    return a + b;
}

void print(std::ostream& os, int result) {
    os << "Sum: " << result << std::endl;
}

Рекомендація: Уникайте дублювання коду
Опис: Дублювання коду ускладнює його підтримку і знижує зрозумілість. 
Приклад:
// поганий приклад
void badDuplication(bool flag) {
    if (flag) {
        std::cout << "True\n";
        std::cout << "Done\n";
    }
    else {
        std::cout << "False\n";
        std::cout << "Done\n";
    }
}

// гарний приклад
void goodRemoveDuplication(bool flag) {
    std::cout << (flag ? "True" : "False") << "\n";
    std::cout << "Done\n";
}

 
ВИСНОВКИ
	
	Підводячи підсумки проведеної роботи, можна зазначити, що мова програмування С++ є багатою на правила та рекомендації, які дозволяють значно підвищити читабельність, зрозумілість, підтримуваність та ефективність коду.
	Узагальнюючи наведені вище рекомендації, можна винести наступні основні правила оформлення та покращення коду на С++:
1. Іменування має бути інтуїтивно зрозумілим та послідовним. Оберіть певний стиль іменування до початку роботи та враховуючи особливості іменування вбудованих С++ структур, та використовуйте інтуїтивно зрозумілі назви.
2. Код має бути простим та зручним для читання. Як і з іменами, оберіть правила використання пустих місць, які будуть зручними для всіх членів команди розробки та які зроблять код читабельним та легким для аналізу.
3. Грамотне використання вбудованих конструкцій допомагає значно підвищити ефективність та читабельність коду. Дотримуйтесь правил, які стосуються використання switch, for, range-for та інших конструкцій, геттерів та сеттерів, тощо, оскільки вони дозволяють значно підвищити продуктивність коду при їх правильному використанні.
4. Необережність під час виконання обчислень може призвести до помилок. Дотримуйтесь правил використання знакових та беззнакових типів та використовуйте дужки, якщо в чомусь невпевнені.
5. Те, що щось можна зробити, не значить, що це робити треба. Як було вказано у вступі, С++ надає програмісту дуже високу степінь свободи у своєму використанні. При цьому достатньо часто ці свободи використовуються недоречно, що призводить до виникнення помилок та значного ускладнення коду там, де це не потрібно.
 
ДОДАТОК А
Список використаних джерел

1. C++ Core Guidelines. GitHub Pages. URL: https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines (date of access: 26.09.2024).
 
ДОДАТОК Б
Відео на YouTube

https://youtu.be/6pNlEdan-pM 

ДОДАТОК В
Презентація

                               
